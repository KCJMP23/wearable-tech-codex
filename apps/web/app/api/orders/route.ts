import { NextRequest, NextResponse } from 'next/server';
import { createServiceClient } from '@/lib/supabase';
import { z } from 'zod';

// Request validation schema
const createOrderSchema = z.object({
  tenant_id: z.string().uuid(),
  customer_email: z.string().email(),
  customer_name: z.string().min(1),
  shipping_address: z.object({
    line1: z.string(),
    line2: z.string().optional(),
    city: z.string(),
    state: z.string(),
    postal_code: z.string(),
    country: z.string(),
  }),
  billing_address: z.object({
    line1: z.string(),
    line2: z.string().optional(),
    city: z.string(),
    state: z.string(),
    postal_code: z.string(),
    country: z.string(),
  }).optional(),
  items: z.array(z.object({
    product_id: z.string().uuid(),
    quantity: z.number().positive(),
    price: z.number().positive(),
    commission_rate: z.number().min(0).max(1).optional(),
  })),
  payment_method: z.object({
    type: z.enum(['credit_card', 'paypal', 'bank_transfer']),
    gateway: z.string(),
    gateway_payment_id: z.string().optional(),
  }).optional(),
  affiliate_id: z.string().optional(),
  notes: z.string().optional(),
});

const updateOrderSchema = z.object({
  status: z.enum(['draft', 'pending_payment', 'paid', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded']).optional(),
  tracking_number: z.string().optional(),
  notes: z.string().optional(),
  shipped_at: z.string().optional(),
  delivered_at: z.string().optional(),
});

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const tenantId = searchParams.get('tenant_id');
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');
    const status = searchParams.get('status');
    const customerId = searchParams.get('customer_id');
    const affiliateId = searchParams.get('affiliate_id');

    if (!tenantId) {
      return NextResponse.json({ error: 'tenant_id is required' }, { status: 400 });
    }

    const supabase = createServiceClient();

    let query = supabase
      .from('orders_detailed')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (status) {
      query = query.eq('status', status);
    }

    if (customerId) {
      query = query.eq('customer_id', customerId);
    }

    if (affiliateId) {
      query = query.eq('affiliate_id', affiliateId);
    }

    const { data: orders, error } = await query;

    if (error) {
      console.error('Error fetching orders:', error);
      return NextResponse.json({ error: 'Failed to fetch orders' }, { status: 500 });
    }

    // Get total count for pagination
    let countQuery = supabase
      .from('orders')
      .select('id', { count: 'exact', head: true })
      .eq('tenant_id', tenantId);

    if (status) {
      countQuery = countQuery.eq('status', status);
    }

    if (customerId) {
      countQuery = countQuery.eq('customer_id', customerId);
    }

    if (affiliateId) {
      countQuery = countQuery.eq('affiliate_id', affiliateId);
    }

    const { count } = await countQuery;

    return NextResponse.json({
      orders: orders || [],
      pagination: {
        limit,
        offset,
        total: count || 0,
        hasMore: (offset + limit) < (count || 0),
      },
    });

  } catch (error) {
    console.error('Orders API error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = createOrderSchema.parse(body);

    const supabase = createServiceClient();

    // Start a transaction
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        tenant_id: validatedData.tenant_id,
        order_number: '', // Will be generated by trigger
        customer_id: null, // Will be set after customer creation/lookup
        status: 'draft',
        order_type: validatedData.affiliate_id ? 'affiliate' : 'direct',
        affiliate_id: validatedData.affiliate_id,
        subtotal: 0, // Will be calculated by trigger
        tax_amount: 0,
        shipping_amount: 0,
        discount_amount: 0,
        total_amount: 0, // Will be calculated by trigger
        currency: 'USD',
        shipping_address: validatedData.shipping_address,
        billing_address: validatedData.billing_address || validatedData.shipping_address,
        notes: validatedData.notes,
      })
      .select()
      .single();

    if (orderError) {
      console.error('Error creating order:', orderError);
      return NextResponse.json({ error: 'Failed to create order' }, { status: 500 });
    }

    // Create or get customer
    let customer;
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('id')
      .eq('tenant_id', validatedData.tenant_id)
      .eq('email', validatedData.customer_email)
      .single();

    if (existingCustomer) {
      customer = existingCustomer;
    } else {
      const { data: newCustomer, error: customerError } = await supabase
        .from('customers')
        .insert({
          tenant_id: validatedData.tenant_id,
          email: validatedData.customer_email,
          full_name: validatedData.customer_name,
          status: 'active',
        })
        .select()
        .single();

      if (customerError) {
        console.error('Error creating customer:', customerError);
        return NextResponse.json({ error: 'Failed to create customer' }, { status: 500 });
      }
      customer = newCustomer;
    }

    // Update order with customer ID
    await supabase
      .from('orders')
      .update({ customer_id: customer.id })
      .eq('id', order.id);

    // Create customer address if it doesn't exist
    await supabase
      .from('customer_addresses')
      .upsert({
        customer_id: customer.id,
        type: 'shipping',
        line1: validatedData.shipping_address.line1,
        line2: validatedData.shipping_address.line2,
        city: validatedData.shipping_address.city,
        state: validatedData.shipping_address.state,
        postal_code: validatedData.shipping_address.postal_code,
        country: validatedData.shipping_address.country,
        is_default: true,
      });

    // Create order items
    const orderItems = validatedData.items.map(item => ({
      order_id: order.id,
      product_id: item.product_id,
      quantity: item.quantity,
      unit_price: item.price,
      commission_rate: item.commission_rate || 0,
      total_price: item.price * item.quantity,
    }));

    const { error: itemsError } = await supabase
      .from('order_items')
      .insert(orderItems);

    if (itemsError) {
      console.error('Error creating order items:', itemsError);
      return NextResponse.json({ error: 'Failed to create order items' }, { status: 500 });
    }

    // Create payment record if payment method provided
    if (validatedData.payment_method) {
      await supabase
        .from('payments')
        .insert({
          order_id: order.id,
          payment_method: validatedData.payment_method.type,
          gateway: validatedData.payment_method.gateway,
          gateway_payment_id: validatedData.payment_method.gateway_payment_id,
          amount: 0, // Will be updated when order totals are calculated
          currency: 'USD',
          status: 'pending',
        });
    }

    // Fetch the complete order with all related data
    const { data: completeOrder } = await supabase
      .from('orders_detailed')
      .select('*')
      .eq('id', order.id)
      .single();

    return NextResponse.json({
      success: true,
      order: completeOrder,
    }, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: 'Validation error',
        details: error.errors,
      }, { status: 400 });
    }

    console.error('Order creation error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const orderId = searchParams.get('id');

    if (!orderId) {
      return NextResponse.json({ error: 'Order ID is required' }, { status: 400 });
    }

    const body = await request.json();
    const validatedData = updateOrderSchema.parse(body);

    const supabase = createServiceClient();

    const updateData: any = {};

    if (validatedData.status) {
      updateData.status = validatedData.status;
      
      // Set timestamps based on status
      if (validatedData.status === 'shipped' && !validatedData.shipped_at) {
        updateData.shipped_at = new Date().toISOString();
      }
      if (validatedData.status === 'delivered' && !validatedData.delivered_at) {
        updateData.delivered_at = new Date().toISOString();
      }
    }

    if (validatedData.tracking_number) {
      updateData.tracking_number = validatedData.tracking_number;
    }

    if (validatedData.notes) {
      updateData.notes = validatedData.notes;
    }

    if (validatedData.shipped_at) {
      updateData.shipped_at = validatedData.shipped_at;
    }

    if (validatedData.delivered_at) {
      updateData.delivered_at = validatedData.delivered_at;
    }

    const { data: updatedOrder, error } = await supabase
      .from('orders')
      .update(updateData)
      .eq('id', orderId)
      .select()
      .single();

    if (error) {
      console.error('Error updating order:', error);
      return NextResponse.json({ error: 'Failed to update order' }, { status: 500 });
    }

    // Fetch the complete updated order
    const { data: completeOrder } = await supabase
      .from('orders_detailed')
      .select('*')
      .eq('id', orderId)
      .single();

    return NextResponse.json({
      success: true,
      order: completeOrder,
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: 'Validation error',
        details: error.errors,
      }, { status: 400 });
    }

    console.error('Order update error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}